
# file path: data loading and visualization for single file path like "data_raw/oisst_1982-2024.nc"
FILES_GLOB = "data_raw/sst.day.mean.*.nc" 

# spatial region of interest (ROI) for subsetting
ROI = dict(lat_min=0.0, lat_max=25.0, lon_min=20.0, lon_max=100.0)

# North indian ocean subregions
REGIONS = {
    # NOTE: Values preserved exactly as provided; we can revisit if lat/lon were swapped.
    "ArabianSea":    {"lon_min": 20.0, "lon_max": 78.0, "lat_min": 0.0,  "lat_max": 25.0},
    "BayOfBengal":   {"lon_min": 78.0, "lon_max": 100.0,"lat_min": 0.0,  "lat_max": 25.0},
    "NorthIndianOc": {"lon_min": 20.0, "lon_max": 100.0,"lat_min": 0.0,  "lat_max": 25.0},
}

# IO / plotting options
use_dask = True                 # set False to fully load into memory
chunks = {"time": 90} if use_dask else None
sample_map_date: Optional[str] = None  # e.g., "2019-06-01"; if None, uses first time step found
boxmean_var_name = "sst"        # expected OISST variable name
climatologyPeriod = [1982, 2024]  # WMO baseline for MHW detection

# %% 
def open_sst(files: Union[str, List[str]], chunks=None) -> xr.Dataset:
    """
    Open one or many NetCDF files with xarray.
    - If `files` is a glob string, it will expand and open_mfdataset.
    - If it's a list of paths, open them together.
    - If it's a single file path, open_dataset.

    Returns: xr.Dataset
    """
    if isinstance(files, str):
        p = Path(files)
        if any(ch in files for ch in "*?[]"):
            paths = sorted(str(fp) for fp in Path().glob(files))
            if not paths:
                raise FileNotFoundError(f"No files match glob: {files}")
            ds = xr.open_mfdataset(paths, combine="by_coords", parallel=True, chunks=chunks)
        else:
            if not p.exists():
                raise FileNotFoundError(f"File not found: {files}")
            ds = xr.open_dataset(files, chunks=chunks)
    else:
        # list of paths
        paths = [str(Path(f)) for f in files]
        for f in paths:
            if not Path(f).exists():
                raise FileNotFoundError(f"File not found: {f}")
        ds = xr.open_mfdataset(paths, combine="by_coords", parallel=True, chunks=chunks)
    return ds

def subset_roi(ds: xr.Dataset, roi: Dict[str, float], var: str = "sst") -> xr.Dataset:
    """
    Subset dataset to ROI bounds. Assumes lon is in [0, 360) (OISST-style) and lat in [-90, 90].
    """
    # Make sure coords are named commonly; adapt here if your files use different names.
    lat_name = "lat" if "lat" in ds.coords else "latitude"
    lon_name = "lon" if "lon" in ds.coords else "longitude"

    ds2 = ds.sel(
        **{
            lat_name: slice(roi["lat_min"], roi["lat_max"]),
            lon_name: slice(roi["lon_min"], roi["lon_max"]),
        }
    )
    # Keep only the variable of interest + coords
    if var in ds2:
        return ds2[[var]]
    else:
        raise KeyError(f"Variable '{var}' not found. Available: {list(ds2.data_vars)}")

def print_metadata(ds: xr.Dataset, var: str = "sst") -> None:
    """
    Print concise metadata: dims, coords, time coverage, attrs, and variable attributes.
    """
    # Dim sizes
    print("=== Dimensions ===")
    for k, v in ds.dims.items():
        print(f"{k}: {v}")

    # Coordinates preview
    print("\n=== Coordinates (first few) ===")
    for c in ds.coords:
        arr = ds.coords[c]
        try:
            vals = arr.values
            preview = f"{vals[:3]} ... {vals[-3:]}" if vals.size > 6 else vals
        except Exception:
            preview = arr
        print(f"{c}: {preview}")

    # Time coverage
    if "time" in ds.coords:
        t = pd.to_datetime(ds["time"].values)
        print("\n=== Time Coverage ===")
        print(f"Start: {pd.Timestamp(t[0]).date()}, End: {pd.Timestamp(t[-1]).date()}, Length: {t.size} steps")

    # Global attrs
    print("\n=== Global attributes ===")
    for k, v in ds.attrs.items():
        print(f"{k}: {v}")

    # Variable attrs
    if var in ds:
        print(f"\n=== Variable '{var}' attributes ===")
        for k, v in ds[var].attrs.items():
            print(f"{k}: {v}")